use crate::charts::png::encode_png;

use ab_glyph::{FontRef, PxScale};
use chrono::{DateTime, Duration};
use chrono_tz::Tz;
use common::Kline;
use image::{ImageBuffer, Rgb};
use imageproc::drawing::draw_text_mut;
use m4rs::{bolinger_band, macd, Candlestick as M4rsCandlestick};
use plotters::coord::types::RangedCoordf32;
use plotters::prelude::full_palette::PURPLE;
use plotters::prelude::*;

use plotters::coord::Shift;
use plotters::style::full_palette::{GREEN_100, RED_100};

use std::error::Error;

const B_RED: RGBColor = RGBColor(245, 71, 95);
const B_GREEN: RGBColor = RGBColor(17, 203, 129);
const B_BLACK: RGBColor = RGBColor(22, 26, 30);
const ORANGE: RGBColor = RGBColor(255, 165, 0);

const LABEL_COLOR: image::Rgb<u8> = Rgb([255u8, 255u8, 255u8]);

// Styling structures
#[derive(Clone)]
pub struct PointStyle {
    pub radius: i32,
    pub color: RGBColor,
}

#[derive(Clone)]
pub struct LineStyle {
    pub stroke_width: i32,
    pub color: RGBColor,
}

#[derive(Clone)]
pub struct LabelStyle {
    pub scale: PxScale,
    pub color: Rgb<u8>,
    pub background_color: Rgb<u8>,
    pub offset_x: i32,
    pub offset_y: i32,
}

pub struct ChartMetaData {
    pub title: String,
}

// Helper functions
fn parse_kline_time(timestamp: i64, tz: &Tz) -> DateTime<Tz> {
    DateTime::from_timestamp(timestamp / 1000, 0)
        .unwrap()
        .with_timezone(tz)
}

fn kline_to_m4rs_candlestick(k: &Kline) -> M4rsCandlestick {
    M4rsCandlestick::new(
        k.open_time as u64,
        k.open_price.parse::<f64>().unwrap(),
        k.high_price.parse::<f64>().unwrap(),
        k.low_price.parse::<f64>().unwrap(),
        k.close_price.parse::<f64>().unwrap(),
        k.volume.parse::<f64>().unwrap(),
    )
}

fn setup_macd_chart(
    area: &DrawingArea<BitMapBackend, Shift>,
    past_data: &[Kline],
    timezone: &Tz,
    first_time: DateTime<Tz>,
    last_time: DateTime<Tz>,
    timeframe: &str,
) -> Result<(), Box<dyn Error>> {
    let past_data_m4rs_candles: Vec<M4rsCandlestick> =
        past_data.iter().map(kline_to_m4rs_candlestick).collect();

    // Calculate MACD for the combined dataset
    let macd_result = if !past_data_m4rs_candles.is_empty() {
        macd(&past_data_m4rs_candles, 12, 26, 9)?
    } else {
        vec![]
    };

    // Extract MACD values to determine the y-axis range
    let macd_values: Vec<f32> = macd_result
        .iter()
        .flat_map(|entry| {
            vec![
                entry.macd as f32,
                entry.signal as f32,
                entry.histogram as f32,
            ]
        })
        .collect();

    let min_macd = macd_values.iter().fold(f32::INFINITY, |a, &b| a.min(b));
    let max_macd = macd_values.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));
    let min_macd = min_macd.min(-0.1); // Ensure visibility of small negative values
    let max_macd = max_macd.max(0.1); // Ensure visibility of small positive values

    // Build the MACD chart with the combined range
    let mut macd_chart = ChartBuilder::on(area)
        .margin(20)
        .build_cartesian_2d(first_time..last_time, min_macd..max_macd)?;

    // Draw MACD for the combined data in a single pass
    draw_macd(
        &mut macd_chart,
        &Some(past_data.to_vec()),
        timezone,
        timeframe,
    )?;

    Ok(())
}

fn parse_timeframe_duration(timeframe: &str) -> Duration {
    let (value, unit) = timeframe.split_at(timeframe.len() - 1);
    let value = value.parse::<i64>().unwrap();
    match unit {
        "m" => Duration::minutes(value),
        "h" => Duration::hours(value),
        "d" => Duration::days(value),
        _ => panic!("Unsupported timeframe unit"),
    }
}

fn calculate_delta(timeframe: &str) -> Duration {
    let timeframe_duration = parse_timeframe_duration(timeframe);
    let divisor = match timeframe {
        "1m" | "5m" => 2, // Smaller bars for 1m and 5m
        "1h" => 2,        // Larger bars for 1h
        _ => 3,           // Default for other timeframes
    };
    timeframe_duration / divisor
}

// Chart struct with technical analysis methods
pub struct Chart {
    timezone: Tz,
    timeframe: String,
    past_candle_data: Option<Vec<Kline>>,
    predicted_candle_data: Option<Vec<Kline>>,
    metadata: ChartMetaData,
    font_data: Option<Vec<u8>>,
    candle_width: u32,
    candle_height: u32,
    points: Vec<(f32, f32)>,
    point_style: Option<PointStyle>,
    lines: Vec<[(f32, f32); 2]>,
    line_style: Option<LineStyle>,
    labels: Vec<(f32, f32, String)>,
    label_style: Option<LabelStyle>,
    macd_enabled: bool,
    bollinger_enabled: bool,
    volume_enabled: bool,
}

impl Chart {
    pub fn new(timeframe: &str, timezone: Tz) -> Self {
        Chart {
            timezone,
            timeframe: timeframe.to_string(),
            past_candle_data: None,
            predicted_candle_data: None,
            metadata: ChartMetaData {
                title: String::new(),
            },
            font_data: None,
            candle_width: 10,
            candle_height: 5,
            points: Vec::new(),
            point_style: None,
            lines: Vec::new(),
            line_style: None,
            labels: Vec::new(),
            label_style: None,
            macd_enabled: false,
            bollinger_enabled: false,
            volume_enabled: false,
        }
    }

    // Builder methods
    #[allow(unused)]
    pub fn with_past_candle(mut self, past_candle_data: Vec<Kline>) -> Self {
        self.past_candle_data = Some(past_candle_data);
        self
    }

    #[allow(unused)]
    pub fn with_predicted_candle(mut self, predicted_candle_data: Vec<Kline>) -> Self {
        self.predicted_candle_data = Some(predicted_candle_data);
        self
    }

    #[allow(unused)]
    pub fn with_title(mut self, title: &str) -> Self {
        self.metadata.title = title.to_string();
        self
    }

    #[allow(unused)]
    pub fn with_font_data(mut self, font_data: Vec<u8>) -> Self {
        self.font_data = Some(font_data);
        self
    }

    #[allow(unused)]
    pub fn with_candle_dimensions(mut self, width: u32, height: u32) -> Self {
        self.candle_width = width;
        self.candle_height = height;
        self
    }

    #[allow(unused)]
    pub fn with_points(mut self, points: Vec<(f32, f32)>) -> Self {
        self.points = points;
        self
    }

    #[allow(unused)]
    pub fn with_point_style(mut self, radius: i32, color: RGBColor) -> Self {
        self.point_style = Some(PointStyle { radius, color });
        self
    }

    #[allow(unused)]
    pub fn with_lines(mut self, lines: Vec<[(f32, f32); 2]>) -> Self {
        self.lines = lines;
        self
    }

    #[allow(unused)]
    pub fn with_line_style(mut self, stroke_width: i32, color: RGBColor) -> Self {
        self.line_style = Some(LineStyle {
            stroke_width,
            color,
        });
        self
    }

    #[allow(unused)]
    pub fn with_labels(mut self, labels: Vec<(f32, f32, String)>) -> Self {
        self.labels = labels;
        self
    }

    #[allow(unused)]
    pub fn with_label_style(
        mut self,
        scale_x: f32,
        scale_y: f32,
        color: Rgb<u8>,
        background_color: Rgb<u8>,
        offset_x: i32,
        offset_y: i32,
    ) -> Self {
        self.label_style = Some(LabelStyle {
            scale: PxScale {
                x: scale_x,
                y: scale_y,
            },
            color,
            background_color,
            offset_x,
            offset_y,
        });
        self
    }

    // Technical analysis methods
    #[allow(unused)]
    pub fn with_macd(mut self) -> Self {
        self.macd_enabled = true;
        self
    }

    #[allow(unused)]
    pub fn with_bollinger_band(mut self) -> Self {
        self.bollinger_enabled = true;
        self
    }

    #[allow(unused)]
    pub fn with_volume(mut self) -> Self {
        self.volume_enabled = true;
        self
    }

    pub fn build(self) -> Result<Vec<u8>, Box<dyn Error>> {
        if self.past_candle_data.is_none() && self.predicted_candle_data.is_none() {
            return Err("At least one candle data set is required".into());
        }
        let font_data = self.font_data.ok_or("Font data is required")?;
        let font = FontRef::try_from_slice(&font_data)?;
        let timezone = &self.timezone;
        let all_candle_data = match (&self.past_candle_data, &self.predicted_candle_data) {
            (Some(past), Some(pred)) => [past.clone(), pred.clone()].concat(),
            (Some(past), None) => past.clone(),
            (None, Some(pred)) => pred.clone(),
            (None, None) => unreachable!(),
        };

        let all_candle_data = &all_candle_data[40..];

        let num_candles = all_candle_data.len() as u32;
        let calculated_width = num_candles * self.candle_width;
        let calculated_height = num_candles * self.candle_height + 200;
        const MIN_DIMENSION: u32 = 768;
        let width = calculated_width.max(MIN_DIMENSION);
        let height = calculated_height.max(MIN_DIMENSION);

        // Step 4: Adjust graph width to 80% for plotting, reserve 20% for labels
        let plot_width = (width as f32 * 0.8) as u32; // 80% for plotting

        let mut buffer = vec![0; (width * height * 3) as usize];

        {
            let root =
                BitMapBackend::with_buffer(&mut buffer, (plot_width, height)).into_drawing_area();
            root.fill(&B_BLACK)?;

            // Sequential splitting for four sections using percentages
            let (candlestick_area, remaining_area) = root.split_vertically((50).percent()); // 50% for candlestick
            let (volume_area, temp_area) = remaining_area.split_vertically((25).percent()); // 25% of remaining (~12.5% of total)
            let (macd_area, stoch_rsi_area) = temp_area.split_vertically((50).percent()); // 50% of remaining (~12.5% of total)

            let prices: Vec<f32> = all_candle_data
                .iter()
                .flat_map(|k| {
                    vec![
                        k.open_price.parse::<f32>().unwrap(),
                        k.high_price.parse::<f32>().unwrap(),
                        k.low_price.parse::<f32>().unwrap(),
                        k.close_price.parse::<f32>().unwrap(),
                    ]
                })
                .collect();
            let min_price = prices.iter().fold(f32::INFINITY, |a, &b| a.min(b));
            let max_price = prices.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));

            let first_time = parse_kline_time(all_candle_data[0].open_time, timezone);
            let last_time = parse_kline_time(
                all_candle_data[all_candle_data.len() - 1].open_time,
                timezone,
            );

            // Candlestick Chart
            let mut candlestick_chart = ChartBuilder::on(&candlestick_area)
                .margin(20)
                .build_cartesian_2d(first_time..last_time, min_price * 0.95..max_price * 1.05)?;

            if let Some(past_candle_data) = &self.past_candle_data {
                draw_candlesticks(
                    &mut candlestick_chart,
                    past_candle_data,
                    timezone,
                    |is_bullish| {
                        if is_bullish {
                            B_GREEN.into()
                        } else {
                            B_RED.into()
                        }
                    },
                )?;
            }

            if self.bollinger_enabled {
                let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);
                draw_bollinger_bands(&mut candlestick_chart, past_data, timezone)?;
            }

            let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);

            // Volume Chart
            if self.volume_enabled {
                let volumes: Vec<f32> = past_data
                    .iter()
                    .map(|k| k.volume.parse::<f32>().unwrap())
                    .collect();
                let max_volume = volumes.iter().fold(0.0f32, |a, &b| a.max(b));
                let mut volume_chart = ChartBuilder::on(&volume_area)
                    .margin(20)
                    .build_cartesian_2d(first_time..last_time, 0.0f32..max_volume * 1.1)?;
                draw_volume_bars(&mut volume_chart, &Some(past_data.to_vec()), timezone)?;
            }

            // Stochastic RSI Chart
            let mut stoch_rsi_chart = ChartBuilder::on(&stoch_rsi_area)
                .margin(20)
                .build_cartesian_2d(first_time..last_time, 0.0f32..100.0f32)?;

            let past_m4rs_candles: Vec<M4rsCandlestick> =
                past_data.iter().map(kline_to_m4rs_candlestick).collect();
            let stoch_rsi_result = m4rs::slow_stochastics(&past_m4rs_candles, 14, 3, 5)?;
            let stoch_rsi_lines: Vec<(DateTime<Tz>, f32, f32)> = stoch_rsi_result
                .iter()
                .map(|entry| {
                    let t = parse_kline_time(entry.at as i64, timezone);
                    (t, entry.k as f32, entry.d as f32)
                })
                .collect();

            let k_style = ShapeStyle::from(&CYAN).stroke_width(2);
            let d_style = ShapeStyle::from(&ORANGE).stroke_width(2);
            stoch_rsi_chart.draw_series(LineSeries::new(
                stoch_rsi_lines.iter().map(|(t, k, _)| (*t, *k)),
                k_style,
            ))?;
            stoch_rsi_chart.draw_series(LineSeries::new(
                stoch_rsi_lines.iter().map(|(t, _, d)| (*t, *d)),
                d_style,
            ))?;

            // Draw upper (80) and lower (20) lines for Stochastic RSI
            let upper_line = 80.0f32;
            let lower_line = 20.0f32;
            stoch_rsi_chart.draw_series(LineSeries::new(
                vec![(first_time, upper_line), (last_time, upper_line)],
                ShapeStyle::from(&WHITE).stroke_width(1),
            ))?;
            stoch_rsi_chart.draw_series(LineSeries::new(
                vec![(first_time, lower_line), (last_time, lower_line)],
                ShapeStyle::from(&WHITE).stroke_width(1),
            ))?;
        }
        // Step 2: Add TA Detail (MA, BB)
        let mut imgbuf: ImageBuffer<Rgb<u8>, Vec<u8>> = ImageBuffer::new(width, height);
        imgbuf.copy_from_slice(buffer.as_slice());

        // Calculate approximate heights based on splits
        let total_height = height as i32;
        let candlestick_end = total_height / 2; // 50% of height
        let volume_end = candlestick_end + (total_height - candlestick_end) / 4; // 25% of remaining
        let macd_end = volume_end + (total_height - volume_end) / 2; // 50% of remaining

        {
            // Step 1: Add Candle Detail
            if let Some(past_candle_data) = &self.past_candle_data {
                let latest_candle = past_candle_data.last().unwrap();
                let open = latest_candle.open_price.parse::<f32>().unwrap();
                let high = latest_candle.high_price.parse::<f32>().unwrap();
                let low = latest_candle.low_price.parse::<f32>().unwrap();
                let close = latest_candle.close_price.parse::<f32>().unwrap();
                let change = ((close - open) / open * 100.0).round() / 100.0;
                let candle_detail = format!(
                    "{} {} O {:.2} H {:.2} L {:.2} C {:.2} {} ({:.2}%)",
                    self.metadata.title.split(' ').next().unwrap_or(""),
                    self.timeframe,
                    open,
                    high,
                    low,
                    close,
                    if change >= 0.0 { "+" } else { "" },
                    change
                );
                draw_text_mut(
                    &mut imgbuf,
                    LABEL_COLOR,
                    10,
                    10,
                    PxScale { x: 30.0, y: 30.0 },
                    &font,
                    &candle_detail,
                );
            }
        }
        {
            if self.bollinger_enabled {
                let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);
                let past_m4rs_candles: Vec<M4rsCandlestick> =
                    past_data.iter().map(kline_to_m4rs_candlestick).collect();
                let bb_result = bolinger_band(&past_m4rs_candles, 20)?;
                let latest_bb = bb_result.last().unwrap();
                let ma_7 = past_m4rs_candles
                    .iter()
                    .rev()
                    .take(7)
                    .map(|c| c.close)
                    .sum::<f64>()
                    / 7.0;
                let ma_25 = past_m4rs_candles
                    .iter()
                    .rev()
                    .take(25)
                    .map(|c| c.close)
                    .sum::<f64>()
                    / 25.0;
                let ma_99 = past_m4rs_candles
                    .iter()
                    .rev()
                    .take(99)
                    .map(|c| c.close)
                    .sum::<f64>()
                    / 99.0;
                let ta_detail = format!(
                    "MA 7 close 0 SMA 9 {:.2}\nMA 25 close 0 SMA 9 {:.2}\nMA 99 close 0 SMA 9 {:.2}\nBB 20 2 {:.2} {:.2} {:.2}",
                    ma_7, ma_25, ma_99, latest_bb.avg, latest_bb.avg + 2.0 * latest_bb.sigma, latest_bb.avg - 2.0 * latest_bb.sigma
                );
                let mut y_offset = 50;
                for line in ta_detail.lines() {
                    draw_text_mut(
                        &mut imgbuf,
                        LABEL_COLOR,
                        10,
                        y_offset,
                        PxScale { x: 20.0, y: 20.0 },
                        &font,
                        line,
                    );
                    y_offset += 25;
                }
            }

            // Step 3: Add MACD Detail
            if self.macd_enabled {
                let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);
                let past_m4rs_candles: Vec<M4rsCandlestick> =
                    past_data.iter().map(kline_to_m4rs_candlestick).collect();
                let macd_result = macd(&past_m4rs_candles, 12, 26, 9)?;
                let latest_macd = macd_result.last().unwrap();
                let macd_detail = format!(
                    "MACD 12 26 close 9 {:.2} {:.2} {:.2}",
                    latest_macd.macd, latest_macd.signal, latest_macd.histogram
                );
                draw_text_mut(
                    &mut imgbuf,
                    LABEL_COLOR,
                    10,
                    candlestick_end + 20, // Position just below candlestick section
                    PxScale { x: 20.0, y: 20.0 },
                    &font,
                    &macd_detail,
                );
            }

            // Step 4: Draw Number Values on the Right
            let price_range = all_candle_data
                .iter()
                .flat_map(|k| {
                    vec![
                        k.open_price.parse::<f32>().unwrap(),
                        k.high_price.parse::<f32>().unwrap(),
                        k.low_price.parse::<f32>().unwrap(),
                        k.close_price.parse::<f32>().unwrap(),
                    ]
                })
                .collect::<Vec<f32>>();
            let min_price = price_range.iter().fold(f32::INFINITY, |a, &b| a.min(b));
            let max_price = price_range.iter().fold(f32::NEG_INFINITY, |a, &b| a.max(b));
            let price_step = (max_price - min_price) / 5.0;
            for i in 0..=5 {
                let price = min_price + price_step * i as f32;
                let y_pos = (candlestick_end as f32
                    * (1.0 - (price - min_price) / (max_price - min_price)))
                    as i32;
                draw_text_mut(
                    &mut imgbuf,
                    LABEL_COLOR,
                    width as i32 - 100,
                    y_pos,
                    PxScale { x: 20.0, y: 20.0 },
                    &font,
                    &format!("{:.2}", price),
                );
            }

            // Step 5: Add Volume Detail
            if self.volume_enabled {
                let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);
                let volume_sma: f32 = past_data
                    .iter()
                    .rev()
                    .take(9)
                    .map(|k| k.volume.parse::<f32>().unwrap())
                    .sum::<f32>()
                    / 9.0;
                let volume_detail = format!("Volume SMA 9 {:.2}K", volume_sma / 1000.0);
                draw_text_mut(
                    &mut imgbuf,
                    LABEL_COLOR,
                    10,
                    volume_end + 20, // Position in the Volume section
                    PxScale { x: 20.0, y: 20.0 },
                    &font,
                    &volume_detail,
                );
            }

            // Step 6: Add Stochastic RSI Detail
            let past_data = self.past_candle_data.as_deref().unwrap_or(&[]);
            let past_m4rs_candles: Vec<M4rsCandlestick> =
                past_data.iter().map(kline_to_m4rs_candlestick).collect();
            let stoch_rsi_result = m4rs::slow_stochastics(&past_m4rs_candles, 14, 3, 5)?;
            let latest_stoch_rsi = stoch_rsi_result.last().unwrap();
            let stoch_rsi_detail = format!(
                "Stock RSI 14 14 3 {:.2} {:.2}",
                latest_stoch_rsi.k, latest_stoch_rsi.d
            );
            draw_text_mut(
                &mut imgbuf,
                LABEL_COLOR,
                10,
                macd_end + 20, // Position in the Stochastic RSI section
                PxScale { x: 20.0, y: 20.0 },
                &font,
                &stoch_rsi_detail,
            );

            // Add Stochastic RSI Y-axis labels (0, 25, 50, 75, 100)
            let stoch_rsi_start = macd_end;
            let stoch_rsi_height = total_height - stoch_rsi_start;
            for i in 0..=4 {
                let value = i as f32 * 25.0;
                let y_pos =
                    stoch_rsi_start + (stoch_rsi_height as f32 * (1.0 - value / 100.0)) as i32;
                draw_text_mut(
                    &mut imgbuf,
                    LABEL_COLOR,
                    width as i32 - 100,
                    y_pos,
                    PxScale { x: 20.0, y: 20.0 },
                    &font,
                    &format!("{:.0}", value),
                );
            }
        }

        Ok(encode_png(&imgbuf)?)
    }
}

// Helper drawing functions
fn draw_candlesticks<F>(
    chart: &mut ChartContext<
        '_,
        BitMapBackend<'_>,
        Cartesian2d<RangedDateTime<DateTime<Tz>>, RangedCoordf32>,
    >,
    candle_data: &[Kline],
    timezone: &Tz,
    color_selector: F,
) -> Result<(), Box<dyn Error>>
where
    F: Fn(bool) -> RGBAColor,
{
    chart.draw_series(candle_data.iter().map(|k| {
        let open = k.open_price.parse::<f32>().unwrap();
        let high = k.high_price.parse::<f32>().unwrap();
        let low = k.low_price.parse::<f32>().unwrap();
        let close = k.close_price.parse::<f32>().unwrap();
        let is_bullish = close >= open;
        let color = color_selector(is_bullish);
        CandleStick::new(
            parse_kline_time(k.open_time, timezone),
            open,
            high,
            low,
            close,
            ShapeStyle::from(&color).filled(),
            ShapeStyle::from(&color).filled(),
            8,
        )
    }))?;
    Ok(())
}

fn draw_bollinger_bands(
    chart: &mut ChartContext<
        '_,
        BitMapBackend<'_>,
        Cartesian2d<RangedDateTime<DateTime<Tz>>, RangedCoordf32>,
    >,
    past_data: &[Kline],
    timezone: &Tz,
) -> Result<(), Box<dyn Error>> {
    // Draw Bollinger Bands for past data
    if !past_data.is_empty() {
        let past_m4rs_candles: Vec<M4rsCandlestick> =
            past_data.iter().map(kline_to_m4rs_candlestick).collect();
        let past_bb_result = bolinger_band(&past_m4rs_candles, 20)?;
        let past_bb_lines: Vec<(DateTime<Tz>, f32, f32, f32)> = past_bb_result
            .iter()
            .map(|entry| {
                let t = parse_kline_time(entry.at as i64, timezone);
                let avg = entry.avg as f32;
                let upper = (entry.avg + 2.0 * entry.sigma) as f32;
                let lower = (entry.avg - 2.0 * entry.sigma) as f32;
                (t, avg, upper, lower)
            })
            .collect();

        let past_style = ShapeStyle::from(&PURPLE).stroke_width(2);
        chart.draw_series(LineSeries::new(
            past_bb_lines.iter().map(|(t, avg, _, _)| (*t, *avg)),
            past_style,
        ))?;
        chart.draw_series(LineSeries::new(
            past_bb_lines.iter().map(|(t, _, upper, _)| (*t, *upper)),
            past_style,
        ))?;
        chart.draw_series(LineSeries::new(
            past_bb_lines.iter().map(|(t, _, _, lower)| (*t, *lower)),
            past_style,
        ))?;
    }

    Ok(())
}

fn draw_volume_bars(
    chart: &mut ChartContext<
        '_,
        BitMapBackend<'_>,
        Cartesian2d<RangedDateTime<DateTime<Tz>>, RangedCoordf32>,
    >,
    past_candle_data: &Option<Vec<Kline>>,
    timezone: &Tz,
) -> Result<(), Box<dyn Error>> {
    if let Some(past_data) = past_candle_data {
        chart
            .configure_mesh()
            .light_line_style(RGBColor(48, 48, 48))
            .draw()?;

        chart.draw_series(past_data.iter().map(|k| {
            let time = parse_kline_time(k.open_time, timezone);
            let volume = k.volume.parse::<f32>().unwrap();
            let bar_width = chrono::Duration::minutes(1);
            Rectangle::new(
                [(time, 0.0), (time + bar_width, volume)],
                ShapeStyle::from(&B_GREEN).filled(),
            )
        }))?;
    }
    Ok(())
}

fn draw_macd(
    chart: &mut ChartContext<
        '_,
        BitMapBackend<'_>,
        Cartesian2d<RangedDateTime<DateTime<Tz>>, RangedCoordf32>,
    >,
    past_candle_data: &Option<Vec<Kline>>,
    timezone: &Tz,
    timeframe: &str,
) -> Result<(), Box<dyn Error>> {
    if let Some(past_data) = past_candle_data {
        let past_m4rs_candles: Vec<M4rsCandlestick> =
            past_data.iter().map(kline_to_m4rs_candlestick).collect();
        let macd_result = macd(&past_m4rs_candles, 12, 26, 9)?;
        let macd_lines: Vec<(DateTime<Tz>, f32, f32, f32)> = macd_result
            .iter()
            .map(|entry| {
                let t = parse_kline_time(entry.at as i64, timezone);
                (
                    t,
                    entry.macd as f32,
                    entry.signal as f32,
                    entry.histogram as f32,
                )
            })
            .collect();

        let m_style = ShapeStyle::from(&MAGENTA).stroke_width(2);
        let s_style = ShapeStyle::from(&CYAN).stroke_width(2);
        chart.draw_series(LineSeries::new(
            macd_lines.iter().map(|(t, m, _, _)| (*t, *m)),
            m_style,
        ))?;

        chart.draw_series(LineSeries::new(
            macd_lines.iter().map(|(t, _, s, _)| (*t, *s)),
            s_style,
        ))?;

        let plotting_area = chart.plotting_area();
        let mut previous_h: Option<f32> = None;
        let delta = calculate_delta(timeframe);
        let limit = 0.02f32;

        for (t, _, _, h) in macd_lines.iter() {
            let is_lower = if let Some(prev) = previous_h {
                *h < prev
            } else {
                false
            };

            let h = if h.abs() > limit {
                h
            } else {
                &(h.signum() * limit)
            };

            let fill_color = if *h > 0.0 {
                if is_lower {
                    GREEN_100
                } else {
                    B_GREEN
                }
            } else if is_lower {
                RED_100
            } else {
                B_RED
            };

            let fill_style = ShapeStyle {
                color: fill_color.into(),
                filled: true,
                stroke_width: 0,
            };

            let stroke_style = ShapeStyle {
                color: B_BLACK.into(),
                filled: false,
                stroke_width: 1,
            };

            plotting_area.draw(&Rectangle::new(
                [(*t - delta, 0.0), (*t + delta, *h)],
                fill_style,
            ))?;

            plotting_area.draw(&Rectangle::new(
                [(*t - delta, 0.0), (*t + delta, *h)],
                stroke_style,
            ))?;

            previous_h = Some(*h);
        }
    }
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    use chrono_tz::Asia::Tokyo;
    use common::binance::fetch_binance_kline_data;
    use image::Rgb;

    #[tokio::test]
    async fn entry_point() {
        let pair_symbol = "SOL_USDT";
        let timeframe = "1h";
        let font_data = include_bytes!("../../Roboto-Light.ttf").to_vec();

        let limit = 240;
        let candle_data = fetch_binance_kline_data::<Kline>(pair_symbol, timeframe, limit)
            .await
            .unwrap();

        let png = Chart::new(timeframe, Tokyo)
            .with_past_candle(candle_data)
            .with_title(&format!("{pair_symbol} {timeframe}"))
            .with_font_data(font_data)
            .with_candle_dimensions(10, 5)
            .with_macd()
            .with_bollinger_band()
            .with_labels(vec![(0.75, 0.25, "71% BULL".to_string())])
            .with_label_style(20.0, 20.0, Rgb([0, 0, 255]), Rgb([0, 255, 255]), 10, 5)
            .build()
            .unwrap();

        std::fs::write("test.png", png).unwrap();
    }
}
